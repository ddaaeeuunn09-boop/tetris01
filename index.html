document.addEventListener('DOMContentLoaded', () => {
    // 1. 기본 설정
    const grid = document.querySelector('.grid');
    const nextGrid = document.querySelector('.next-grid');
    const scoreDisplay = document.querySelector('.score-display');
    const startButton = document.querySelector('.start-button');
    const width = 10; // 게임 보드 너비 (10칸)
    let nextWidth = 4; // 다음 블록 보드 너비 (4칸)
    let squares = Array.from(grid.querySelectorAll('div'));
    let nextSquares = Array.from(nextGrid.querySelectorAll('div'));
    let timerId; // 게임 루프 타이머
    let score = 0;
    let isGameOver = false;
    let isPaused = true;

    // 2. 게임 보드 초기화: 200개의 셀 + 10개의 고스트 셀
    for (let i = 0; i < 210; i++) {
        const div = document.createElement('div');
        if (i >= 200) {
            div.classList.add('taken'); // 바닥을 'taken'으로 표시
        }
        grid.appendChild(div);
    }
    squares = Array.from(grid.querySelectorAll('div'));

    // 3. 다음 블록 보드 초기화
    for (let i = 0; i < 16; i++) {
        const div = document.createElement('div');
        nextGrid.appendChild(div);
    }
    nextSquares = Array.from(nextGrid.querySelectorAll('div'));


    // 4. 테트로미노(Tetrominoes) 모양 정의 (7가지 블록)
    // 각 블록은 4개의 셀로 구성되며, 회전 형태를 모두 포함합니다.
    const lTetromino = [
        [1, width + 1, width * 2 + 1, 2],
        [width, width + 1, width + 2, width * 2 + 2],
        [1, width + 1, width * 2 + 1, width * 2],
        [width, width * 2, width * 2 + 1, width * 2 + 2]
    ];
    // ... 나머지 6개의 블록도 정의 (J, I, O, S, Z, T)
    const jTetromino = [
        [0, width, width * 2, width * 2 + 1],
        [width, width + 1, width + 2, width * 2],
        [1, width + 1, width * 2 + 1, width * 2],
        [width, width * 2, width * 2 + 1, width * 2 + 2]
    ];

    const iTetromino = [
        [1, width + 1, width * 2 + 1, width * 3 + 1],
        [width, width + 1, width + 2, width + 3],
        [1, width + 1, width * 2 + 1, width * 3 + 1],
        [width, width + 1, width + 2, width + 3]
    ];

    const oTetromino = [
        [0, 1, width, width + 1],
        [0, 1, width, width + 1],
        [0, 1, width, width + 1],
        [0, 1, width, width + 1]
    ];

    const sTetromino = [
        [width + 1, width + 2, width * 2, width * 2 + 1],
        [1, width + 1, width + 2, width * 2 + 2],
        [width + 1, width + 2, width * 2, width * 2 + 1],
        [1, width + 1, width + 2, width * 2 + 2]
    ];

    const zTetromino = [
        [width, width + 1, width * 2 + 1, width * 2 + 2],
        [width * 2 + 1, width * 2, width + 1, width],
        [width, width + 1, width * 2 + 1, width * 2 + 2],
        [width * 2 + 1, width * 2, width + 1, width]
    ];

    const tTetromino = [
        [1, width, width + 1, width + 2],
        [1, width + 1, width + 2, width * 2 + 1],
        [width, width + 1, width + 2, width * 2 + 1],
        [1, width, width + 1, width * 2 + 1]
    ];

    const theTetrominoes = [lTetromino, jTetromino, iTetromino, oTetromino, sTetromino, zTetromino, tTetromino];
    const colors = ['l', 'j', 'i', 'o', 's', 'z', 't']; // CSS 클래스와 일치

    let currentPosition = 4; // 시작 위치
    let currentRotation = 0; // 초기 회전 상태
    let random = Math.floor(Math.random() * theTetrominoes.length);
    let current = theTetrominoes[random][currentRotation];
    let currentColor = colors[random];
    let nextRandom = Math.floor(Math.random() * theTetrominoes.length);

    // 5. 블록 그리기
    function draw() {
        if (!current) return;
        current.forEach(index => {
            squares[currentPosition + index].classList.add('block', currentColor);
        });
    }

    // 6. 블록 지우기
    function undraw() {
        if (!current) return;
        current.forEach(index => {
            squares[currentPosition + index].classList.remove('block', currentColor);
        });
    }

    // 7. 블록 아래로 이동
    function moveDown() {
        if (isPaused || isGameOver) return;
        undraw();
        currentPosition += width;
        if (checkCollision()) {
            currentPosition -= width;
            freeze();
        }
        draw();
    }

    // 8. 충돌 감지
    function checkCollision() {
        return current.some(index =>
            squares[currentPosition + index].classList.contains('taken')
        );
    }

    // 9. 블록 고정 (Freeze) 및 새 블록 생성
    function freeze() {
        current.forEach(index => squares[currentPosition + index].classList.add('taken'));
        addScore();
        generateNewPiece();
        gameOver();
    }

    // 10. 새 블록 생성
    function generateNewPiece() {
        random = nextRandom;
        nextRandom = Math.floor(Math.random() * theTetrominoes.length);
        current = theTetrominoes[random][0]; // 새로운 블록은 0도 회전 상태로 시작
        currentColor = colors[random];
        currentPosition = 4;
        currentRotation = 0;
        
        draw();
        displayNextPiece();

        // 새 블록 생성 시 바로 충돌 체크 (게임 오버 조건)
        if (checkCollision()) {
            gameOver();
        }
    }

    // 11. 다음 블록 표시
    const displayShapes = [
        [1, nextWidth + 1, nextWidth * 2 + 1, 2], // L
        [0, nextWidth, nextWidth * 2, nextWidth * 2 + 1], // J
        [1, nextWidth + 1, nextWidth * 2 + 1, nextWidth * 3 + 1], // I
        [0, 1, nextWidth, nextWidth + 1], // O
        [nextWidth + 1, nextWidth + 2, nextWidth * 2, nextWidth * 2 + 1], // S
        [nextWidth, nextWidth + 1, nextWidth * 2 + 1, nextWidth * 2 + 2], // Z
        [1, nextWidth, nextWidth + 1, nextWidth + 2] // T
    ];

    function displayNextPiece() {
        // 다음 보드 초기화
        nextSquares.forEach(square => {
            square.classList.remove('block', ...colors);
        });

        // 다음 블록 그리기
        displayShapes[nextRandom].forEach(index => {
            nextSquares[index].classList.add('block', colors[nextRandom]);
        });
    }


    // 12. 키 입력 제어
    function control(e) {
        if (isPaused || isGameOver) return;
        if (e.keyCode === 37) { // 왼쪽 화살표
            moveLeft();
        } else if (e.keyCode === 38) { // 위쪽 화살표 (회전)
            rotate();
        } else if (e.keyCode === 39) { // 오른쪽 화살표
            moveRight();
        } else if (e.keyCode === 40) { // 아래쪽 화살표
            moveDown(); // 일반적인 하강 속도로 한 칸 이동
        } else if (e.keyCode === 32) { // 스페이스바 (하드 드롭)
            hardDrop();
        }
    }
    document.addEventListener('keydown', control);

    // 13. 왼쪽 이동
    function moveLeft() {
        undraw();
        const isAtLeftEdge = current.some(index => (currentPosition + index) % width === 0);
        if (!isAtLeftEdge) currentPosition -= 1;
        if (checkCollision()) {
            currentPosition += 1; // 충돌 시 되돌리기
        }
        draw();
    }

    // 14. 오른쪽 이동
    function moveRight() {
        undraw();
        const isAtRightEdge = current.some(index => (currentPosition + index) % width === width - 1);
        if (!isAtRightEdge) currentPosition += 1;
        if (checkCollision()) {
            currentPosition -= 1; // 충돌 시 되돌리기
        }
        draw();
    }

    // 15. 회전
    function rotate() {
        undraw();
        currentRotation++;
        if (currentRotation === current.length) { // 마지막 회전 상태를 넘어가면 0으로 리셋
            currentRotation = 0;
        }
        current = theTetrominoes[random][currentRotation];

        // 벽차기 (Wall Kicks)는 구현하지 않고 간단한 충돌 방지 로직만 적용
        if (checkCollision()) {
            currentRotation--;
            if (currentRotation < 0) currentRotation = current.length - 1;
            current = theTetrominoes[random][currentRotation];
        }

        draw();
    }

    // 16. 하드 드롭 (스페이스바)
    function hardDrop() {
        if (isPaused || isGameOver) return;
        let originalPosition = currentPosition;
        
        // 충돌할 때까지 한 칸씩 아래로 이동
        while (!checkCollision()) {
            undraw();
            currentPosition += width;
        }
        
        currentPosition -= width; // 충돌 지점에서 한 칸 위로 되돌리기
        draw();
        freeze(); // 블록 고정
    }

    // 17. 줄 제거 및 점수 계산
    function addScore() {
        for (let i = 0; i < 199; i += width) {
            const row = [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8, i + 9];

            if (row.every(index => squares[index].classList.contains('taken'))) {
                score += 10;
                scoreDisplay.innerHTML = `점수: ${score}`;

                // 줄 제거
                row.forEach(index => {
                    squares[index].classList.remove('taken', 'block', ...colors);
                });

                // 위에 있는 블록들을 아래로 이동
                const squaresRemoved = squares.splice(i, width);
                squares = squaresRemoved.concat(squares);
                squares.forEach(cell => grid.appendChild(cell));
            }
        }
    }


    // 18. 게임 오버
    function gameOver() {
        if (current.some(index => squares[currentPosition + index].classList.contains('taken'))) {
            scoreDisplay.innerHTML = '게임 오버! 최종 점수: ' + score;
            clearInterval(timerId);
            isGameOver = true;
            startButton.innerHTML = '다시 시작';
            document.removeEventListener('keydown', control);
        }
    }

    // 19. 시작/일시정지 버튼
    startButton.addEventListener('click', () => {
        if (isGameOver) {
            // 게임 오버 상태에서 클릭 시 페이지 새로고침으로 간단하게 재시작
            window.location.reload();
            return;
        }

        if (timerId) {
            clearInterval(timerId);
            timerId = null;
            isPaused = true;
            startButton.innerHTML = '계속';
        } else {
            draw();
            displayNextPiece();
            timerId = setInterval(moveDown, 1000); // 1초마다 블록 하강
            isPaused = false;
            startButton.innerHTML = '일시정지';
        }
    });

    // 20. 초기 블록 표시
    displayNextPiece();
});
